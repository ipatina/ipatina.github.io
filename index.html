<!DOCTYPE html>
<html>
<head>
    <title>Минимизация КА</title>
    <script
            src="https://state-machine-cat.js.org/state-machine-cat-inpage.min.js"
            defer>
    </script>
</head>
<body>
<h3>Введите грамматику:</h3>
<label>Нетерминалы =</label>
<input type="text" value="A,B,C,D,E,F,G,H,I,J" id="nonterm" size="20">
<br>
<label>Терминалы =</label>
<input type="text" value="a,b,c,d,~,&,⊥" id="term" size="20">
<br>
<label>Правила =</label>
<input type="text" value="A->cC;C->aE|cF|bG;B->dC;D->dC;E->~B|⊥I;F->&C|⊥I;G->~D|⊥I;H->bE|aI;J->aG|bI" id="rules"
       size="40">
<br>
<label>Начальный символ =</label>
<input type="text" value="A" id="start" size="20">
<br>
<br>
<button type="button" onclick="create_dka()">Устранить недостижимые состояния</button>
<button type="button" onclick="create_dka()">Минимизировать конечный автомат</button>
<br>
<br>
<script type="text/javascript">
    function groupBy(arr, criteria) {
        return arr.reduce(function (acc, currentValue) {
            if (!acc[currentValue[criteria]]) {
                acc[currentValue[criteria]] = [];
            }
            acc[currentValue[criteria]].push(currentValue);
            return acc;
        }, {});
    }

    function create_dka() {
        // получаем строку введенных нетерминалов грамматики
        const nonTerminalStr = document.getElementById('nonterm').value;
        // получаем строку введенных терминалов грамматики
        const terminalStr = document.getElementById('term').value;
        // получаем строку введенных правил грамматики
        const ruleStr = document.getElementById('rules').value;
        // получаем строку введенного начального символа грамматики
        const start = document.getElementById('start').value;

        // подготавливаем структуру данных для конечного автомата
        const NKA = {
            "states": [{
                "name": "start",
                "type": "initial"
            }],
            "transitions": [{
                "from": "start",
                "to": start
            }]
        };

        // создаем структуру данных для детерминированного конечного автомата
        const minKA_1 = JSON.parse(JSON.stringify(NKA));
        const minKA_2 = JSON.parse(JSON.stringify(NKA));

        // заполняем структуру данных для НКА состояниями из нетерминалов
        const nonTerminalArray = nonTerminalStr.split(",")
        nonTerminalArray.forEach(nonTerminal => NKA.states.push({
            "name": nonTerminal.trim(),
            "type": "regular"
        }))

        // добавляем правила грамматики в структуру переходов между состояниями
        ruleStr.split(";")
            .map(rule => rule.split("->"))
            .forEach(rule => {
                rule[1].split("|").forEach(ruleItem => {
                    if (ruleItem.length < 2) {
                        NKA.transitions.push({
                            "from": rule[0],
                            "to": "final",
                            "label": ruleItem
                        });
                    } else {
                        NKA.transitions.push({
                            "from": rule[0],
                            "to": ruleItem.charAt(1),
                            "label": ruleItem.charAt(0)
                        });
                    }
                })
            })

        // console.log(NKA)
        // console.log(JSON.stringify(NKA))

        const dostState = []
        NKA.transitions.forEach(trans => {
            if (!dostState.includes(trans.to)) {
                dostState.push(trans.to)
            }
        })

        NKA.states.forEach(state => {
            if (dostState.includes(state.name)) {
                minKA_1.states.push(state)
            }
        })

        NKA.transitions.forEach(trans => {
            if (trans.from !== "start" && dostState.includes(trans.from)) {
                minKA_1.transitions.push(trans)
            }
        })

        const sorted = nonTerminalArray.sort((a, b) => a.localeCompare(b));
        let lastLetter = String.fromCharCode(sorted[sorted.length - 1].charCodeAt(0) + 1);
        const newNonTerms = [];

        const groupedByFrom = groupBy(minKA_1.transitions, "to");
        const groupedByFromValues = Object.values(groupedByFrom).filter(x => x.length > 1);
        groupedByFromValues.forEach(grp => {
            const groupedByLabel = groupBy(grp, "label");
            const groupedByLabelValues = Object.values(groupedByLabel).filter(x => x.length > 1);
            const allFrom = groupedByLabelValues[0].map(x => x.from);
            newNonTerms.push({
                "from": allFrom,
                "newFrom": lastLetter,
                "to": groupedByLabelValues[0][0].to,
                "label": groupedByLabelValues[0][0].label
            });
            lastLetter = String.fromCharCode(lastLetter.charCodeAt(0) + 1);
        });

        const newTransitions = [];
        const newStates = minKA_1.states.filter(x => x.name === start);

        newNonTerms.forEach(x => {
            newStates.push({
                "name": x.newFrom,
                "type": "regular"
            });
            newStates.push({
                "name": x.to,
                "type": "regular"
            });
        });

        newNonTerms.forEach(x => {
            newTransitions.push({
                "from": x.newFrom,
                "to": x.to,
                "label": x.label
            });
        })

        const updated = minKA_1.transitions.map(trans => {
            newNonTerms.forEach(newNonTerm => {
                if (newNonTerm.from.includes(trans.to)) {
                    trans.to = newNonTerm.newFrom
                }
            })
            return trans;
        });

        updated.forEach(x => {
            let notFound = true;
            newNonTerms.forEach(newNonTerm => {
                if (newNonTerm.from.includes(x.from)) {
                    const existing = newTransitions.filter(newTr => newTr.from === newNonTerm.newFrom && newTr.to === x.to)
                    if (existing.length === 0) {
                        newTransitions.push({
                            "from": newNonTerm.newFrom,
                            "to": x.to,
                            "label": x.label
                        });
                    }
                    notFound = false;
                }
            })
            if (notFound) {
                const existing = newTransitions.filter(newTr => newTr.from === x.from && newTr.to === x.to)
                if (existing.length > 0) {
                    existing[0].label = existing[0].label + "," + x.label;
                } else {
                    newTransitions.push(x);
                }
            }
        })

        minKA_2.states = minKA_2.states.concat(newStates)
        minKA_2.transitions = newTransitions

        console.log(newTransitions);
        console.log(newStates);
        console.log(JSON.stringify(minKA_2))

        // добавляем отрисовку графа ДКА
        // const sc = document.createElement("script");
        // const txt = document.createTextNode(JSON.stringify(DKA));
        // sc.setAttribute("type", "text/x-smcat-json");
        // sc.appendChild(txt);
        // document.body.appendChild(sc);
    }
</script>
<script type="text/x-smcat-json" data-direction="left-right">
{"states":[{"name":"start","type":"initial"},{"name":"A","type":"regular"},{"name":"K","type":"regular"},{"name":"C","type":"regular"},{"name":"L","type":"regular"},{"name":"I","type":"regular"}],"transitions":[{"from":"K","to":"C","label":"d"},{"from":"start","to":"A"},{"from":"A","to":"C","label":"c"},{"from":"C","to":"L","label":"a,c,b"},{"from":"L","to":"K","label":"~"},{"from":"L","to":"C","label":"&amp;"},{"from":"L","to":"I","label":"⊥"}]}
</script>
</body>
</html>
