<!DOCTYPE html>
<html>
<head>
    <title>Минимизация КА</title>
    <script
            src="https://state-machine-cat.js.org/state-machine-cat-inpage.min.js"
            defer>
    </script>
</head>
<body>
<h3>Введите грамматику:</h3>
<label>Нетерминалы =</label>
<input type="text" value="A,B,C,D,E,F,G,H,I,J" id="nonterm" size="20">
<br>
<label>Терминалы =</label>
<input type="text" value="a,b,c,d,~,&,⊥" id="term" size="20">
<br>
<label>Правила =</label>
<input type="text" value="A->cC;C->aE|cF|bG;B->dC;D->dC;E->~B|⊥I;F->&C|⊥I;G->~D|⊥I;H->bE|aI;J->aG|bI" id="rules" size="40">
<br>
<label>Начальный символ =</label>
<input type="text" value="A" id="start" size="20">
<br>
<br>
<button type="button" onclick="create_dka()">Устранить недостижимые состояния</button>
<button type="button" onclick="create_dka()">Минимизировать конечный автомат</button>
<br>
<br>
<script type="text/javascript">
    function groupBy(arr, criteria) {
        return arr.reduce(function (acc, currentValue) {
            if (!acc[currentValue[criteria]]) {
                acc[currentValue[criteria]] = [];
            }
            acc[currentValue[criteria]].push(currentValue);
            return acc;
        }, {});
    }

    function create_dka() {
        // получаем строку введенных нетерминалов грамматики
        const nonTerminalStr = document.getElementById('nonterm').value;
        // получаем строку введенных терминалов грамматики
        const terminalStr = document.getElementById('term').value;
        // получаем строку введенных правил грамматики
        const ruleStr = document.getElementById('rules').value;
        // получаем строку введенного начального символа грамматики
        const start = document.getElementById('start').value;

        // подготавливаем структуру данных для конечного автомата
        const NKA = {
            "states": [{
                "name": "start",
                "type": "initial"
            }, {
                "name": "final",
                "type": "final"
            }],
            "transitions": [{
                "from": "start",
                "to": start
            }]
        };

        // создаем структуру данных для детерминированного конечного автомата
        const minKA_1 = JSON.parse(JSON.stringify(NKA));
        const minKA_2 = JSON.parse(JSON.stringify(NKA));

        // заполняем структуру данных для НКА состояниями из нетерминалов
        const nonTerminalArray = nonTerminalStr.split(",")
        nonTerminalArray.forEach(nonTerminal => NKA.states.push({
            "name": nonTerminal.trim(),
            "type": "regular"
        }))

        // добавляем правила грамматики в структуру переходов между состояниями
        ruleStr.split(";")
            .map(rule => rule.split("->"))
            .forEach(rule => {
                rule[1].split("|").forEach(ruleItem => {
                    if (ruleItem.length < 2) {
                        NKA.transitions.push({
                            "from": rule[0],
                            "to": "final",
                            "label": ruleItem
                        });
                    } else {
                        NKA.transitions.push({
                            "from": rule[0],
                            "to": ruleItem.charAt(1),
                            "label": ruleItem.charAt(0)
                        });
                    }
                })
            })

        // console.log(NKA)
        // console.log(JSON.stringify(NKA))

        const dostState = []
        NKA.transitions.forEach(trans => {
            if (!dostState.includes(trans.to)) {
                dostState.push(trans.to)
            }
        })

        NKA.states.forEach(state => {
            if (dostState.includes(state.name)) {
                minKA_1.states.push(state)
            }
        })

        NKA.transitions.forEach(trans => {
            if (trans.from !== "start" && dostState.includes(trans.from)) {
                minKA_1.transitions.push(trans)
            }
        })

        console.log(minKA_1)
        console.log(JSON.stringify(minKA_1))

        // добавляем отрисовку графа ДКА
        // const sc = document.createElement("script");
        // const txt = document.createTextNode(JSON.stringify(DKA));
        // sc.setAttribute("type", "text/x-smcat-json");
        // sc.appendChild(txt);
        // document.body.appendChild(sc);
    }
</script>
<script type="text/x-smcat-json" data-direction="left-right">
    {"states":[{"name":"start","type":"initial"},{"name":"A","type":"regular"},{"name":"B","type":"regular"},{"name":"C","type":"regular"},{"name":"D","type":"regular"},{"name":"E","type":"regular"},{"name":"F","type":"regular"},{"name":"G","type":"regular"},{"name":"I","type":"regular"}],"transitions":[{"from":"start","to":"A"},{"from":"E","to":"B","label":"~"},{"from":"A","to":"C","label":"c"},{"from":"B","to":"C","label":"d"},{"from":"D","to":"C","label":"d"},{"from":"F","to":"C","label":"&amp;"},{"from":"G","to":"D","label":"~"},{"from":"C","to":"E","label":"a"},{"from":"C","to":"F","label":"c"},{"from":"C","to":"G","label":"b"},{"from":"E","to":"I","label":"⊥"},{"from":"F","to":"I","label":"⊥"},{"from":"G","to":"I","label":"⊥"}]}
</script>
</body>
</html>
